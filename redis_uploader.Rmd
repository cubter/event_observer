---
title: "redis_files_constructor.Rmd"
output: html_document
date: '2022-04-14'
---

```{r setup, include=FALSE}
library(magrittr)
library(purrr)
library(lobstr)
library(redux)
```


```{r}
occurr = read.csv2("Data/occurence.csv", sep = ",", stringsAsFactors = F, 
                    check.names = T,
                   nrows = 300000)

occurr = occurr[c("scientificName", "vernacularName", "latitudeDecimal", "longitudeDecimal", "eventDate", "eventTime")]
```


Constructs a reverted index, containing key-value pairs, where key is a species' 
scientific name, and value is a list containing vernacular name, latitude, longitude, 
date & time of the event.
Note: perhaps I should have parallelized the loop (using `future` pkg e.g.), but I
suppose I have a data dependency here.
```{r}
#TODO: check if sci name size exceeds 10000 bytes
construct_index <- function(scientific_name, vernacular_name, lat, long, event_date, event_time, 
                            row_num) 
{
    if (rlang::env_has(e1, scientific_name)) 
    {
        e1[[scientific_name]][[2]] %<>% append(row_num) # row number (index itself)
        e1[[scientific_name]][[3]] %<>% append(lat)  # latitude      
        e1[[scientific_name]][[4]] %<>% append(long)  # longitude
        e1[[scientific_name]][[5]] %<>% append(event_date)  # date
        e1[[scientific_name]][[6]] %<>% append(event_time)  # time
        
        return()
    }
    
    e1[[scientific_name]] <- list(vernacular_name, row_num, lat, long, event_date, event_time)
    names(e1[[scientific_name]]) <- c(
        "vernacular_name", "row_num", "lat", "long", "event_date", "event_time")
}

e1 <- rlang::env()

purrr::pwalk(list(occurr$scientificName, 
                  occurr$vernacularName, 
                  occurr$latitudeDecimal, 
                  occurr$longitudeDecimal,
                  occurr$eventDate, 
                  occurr$eventTime, 
                  seq_along(occurr$scientificName)
                  ),
             ~ construct_index(..1, ..2, ..3, ..4, ..5, ..6, ..7))
```


Functions that construct appropriate Redis' functions.
```{r}
# "Coordinates" is a list, contaning pairs of latitude & longitude.
set_redis_coordinates <- function(env, env_key, lat, long)
{
    if (!is.null(env[[env_key]]$lat) && !is.null(env[[env_key]]$long))
    {
        coord <- paste(env[[env_key]][[lat]], env[[env_key]][[long]], sep = ",")
        
        env[[env_key]][[lat]] <- NULL
        env[[env_key]][[long]] <- NULL
        
        return(redis$LPUSH(paste(env_key, "coord", sep = ":"), coord))
    }
}

# "Datetime" is a list, contaning pairs of date & time.
set_redis_date_time <- function(env, env_key, event_date, event_time)
{
    if (!is.null(env[[env_key]]$event_date) && !is.null(env[[env_key]]$event_time))
    {
        datetime <- paste(env[[env_key]][[event_date]], env[[env_key]][[event_time]], sep = ",")
        
        env[[env_key]][[event_date]] <- NULL
        env[[env_key]][[event_time]] <- NULL
        
        return(redis$LPUSH(paste(env_key, "datetime", sep = ":"), datetime))
    }
}

# "Names" is a hash, contaning pairs of vernac. names (key) & scient. names (value).
set_redis_name_pairs <- function(scientific_name, vernacular_name,
                                 scheme_name)
{
    return(redis$HSET(scheme_name, vernacular_name, scientific_name))
}

increment_redis_num_events <- function(hash_name, val)
{
    if (!r$EXISTS(hash_name))
    {
        r$HSET(hash_name, "value", 0)
    }
    return(r$HINCRBY(hash_name, "value", val))
}

set_years_distribution <- function(sorted_set_name, score, member)
{
    return(r$ZINCRBY(sorted_set_name, score, member))
}
```

Setting connection to Redis.
```{r echo=F, include=F}
r <- redux::hiredis()
redis <- redux::redis
#TODEL
r$FLUSHDB()
```

Pipelining data to Redis.
```{r echo=FALSE, include=FALSE}
# Pipelining events' coordinates.
cmds <- map(occurr$scientificName, 
            ~ set_redis_coordinates(e1, .x, "lat", "long"))
r$pipeline(.commands = cmds)

# Pipelining events' dates & times.
cmds <- map(occurr$scientificName,
            ~ set_redis_date_time(e1, .x, "event_date", "event_time"))
r$pipeline(.commands = cmds)
 
# Pipelining species' name pairs.
cmds <- map2(occurr$scientificName, occurr$vernacularName,
             ~ set_redis_name_pairs(.x, .y, "vernacular_name:scientific_name"))
r$pipeline(.commands = cmds)

increment_redis_num_events("num_events", nrow(occurr))

years_distribution <- format(as.Date(occurr$eventDate),"%Y") %>% 
    table()

for (i in seq_along(years_distribution)) {
    r$ZINCRBY("yt5", years_distribution[i], names(years_distribution)[i])
    cat(i, "\n")
}

walk2(years_distribution, names(years_distribution),
      ~ r$ZINCRBY("year_count", .x, .y))
```


